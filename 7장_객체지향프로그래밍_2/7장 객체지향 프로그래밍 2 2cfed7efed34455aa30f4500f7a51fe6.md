# 7장. 객체지향 프로그래밍 2

> **목차**
> 
> 
> > **1.  상속
> 2. 오버라이딩
> 3.  package와 import
> 4. 제어자
> 5. 다형성
> 6. 추상클래스
> 7. 인터페이스
> 8. 내부 클래스**
> > 

## 1장 상속

```java
class Child extends Parent{}; // 자식이 부모를 상속했다.
```

> **조상 클래스 : 부모, 상위, 기반

자손 클래스: 자식, 하위, 파생된**
> 

자손 클래스는 조상 클래스의 모든 멤버를 상속받기 때문에, Child 클래스는 Parent 클래스의 멤버들을 포함한다고 할 수 있다. 

조상클래스가 변경되면 자손 클래스는 자동적으로 영향을 받지만, 자손 클래스가 변경되는 것은 부모 클래스에 아무런 영향을 주지 못한다.

상속을 받는다는 것은 조상 클래스를 확장한다는 의미로 해석할 수 있다.

<aside>
💡 **생성자와 초기화 블럭**은 상속되지 않는다. **멤버**만 상속된다.

자식 클래스의 멤버 개수는 조상 클래스보다 항상 많거나 같다.

</aside>

접근 제어자가 private 또는 default인 멤버들은 상속되지 않는다기보다는 상속은 받지만 자손 클래스로부터의 접근이 제한되는 것이다.

클래스 간의 관계에서 형제관계와 같은 것은 없다. 부모관계만이 존재할 뿐.

<aside>
💡 자식 클래스의 인스턴스를 생성하면 부모 클래스의 멤버와 자식 클래스의 멤버가 합 쳐진 하나의 인스턴스로 생성된다.

</aside>

### 포함관계

<aside>
💡 **상속관계 ‘~은 ~이다.’ (is-a 관계)**

</aside>

### 단일 상속

자바는 단일 상속만을 허용한다. 다중 상속의 복잡성과 모호성을 해결하기 위해

### Obejct 클래스_ 모든 클래스의 조상

컴파일러가 상속을 받지 않는 클래스에게 자동으로 extends Object를 붙여 상속을 하게한다.

단 상속을 받도록 작성된 클래스의 경우에는 붙이지 않는다.

## 2장 오버라이딩

### 오버라이딩의 조건

<aside>
💡 자식 클래스에서 오버라이딩하는 메서드는 부모 클래스의 메서드와 

1. **이름**이 같아야함
2. **매개변수**가 같아야함
3. **반환타입**이 같아야함

+a) JDK 1.5부터 공변반환타입이 추가되어 반환타입을 자손 클래스의 타입으로 변경하는 것이 가능하도록 조건 완화가 되었다.

</aside>

선언부는 서로 일치해야한다. 그러나 접근제어자와 예외는 제한된 조건하에서 다르게 변경할 수 있다.

1. **접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.**
2. 조상 클래스의 메서드보다 **많은 수의 예외를 선언할 수 없다**. 

```java
class Parent{
		void parentMethod() throws SQLException, IOEException{}
	} //에러

class Child extends Parent{
		void parentMethod() throws Exception{}
	} //에러
```

분명히 부모 클래스의 정의된 메서드보다 적은 개수의 예외를 던진 것 같지만 아니다. 

Exception은 모든 예외의 최고 조상이므로 가장많은 개수의 예외를  자식 단에서 던질 수 있게 된 것이다.

<aside>
💡 조상 클래스의 메서드를 자식 클래스에서 오버라이딩할 때

1. **접근 제어자**를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
2. **예외**는 조상 클래스의 메서드보다 더 많이 던질 수 없다.
3. **인스턴스메서드를 static**으로, 또는 그 반대도 허용되지 않는다.

</aside>

조상 클래스에 정의된 static 메서드를 자손 클래스에서 똑같은 이름의 statice 메서드로 정의할 수 있다. 그러나 이는 각 클래스에 별개의 static 메서드를 정의한 것 뿐이지 오버라이드는 아니다. 또한 static 메서드는 클래스에 귀속되어있음을 항상 인지할 것.

### super

조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다. 

자신이 속한 인스턴스의 주소가 지역변수로 저장되는데 이게 참조변수인 this와 super가 된다.

static method에서는 사용불가. this도 당연히

super으로 메서드도 사용가능

### super()

**조상 클래스의 멤버변수는 이처럼 조상의 생성자에 의해 초기화되도록 해야하는 것이다..** 

기본은 super()을 추가해주는 것이지만, 만약 디폴트 생성자가 없다면 오류를 뱉을 것.

---

### 3장 package와 import

### package

> 패키지란 클래스의 묶음이다. 

클래스가 물리적으로 하나의 클래스 파일인 것처럼 패키지는 물리적으로 하나의 **디렉토리**이다.
> 

> 하나의 소스파일에는 첫번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
모든 클래스는 반드시 하나의 패키지에 속해야한다.
패키지는 점을 구분자로 하여 **계층구조**를 구성할 수 있다.
패키지는 물리적으로 클래스 파일을 포함하는 하나의 **디렉토리**이다.
> 

### 패키지의 선언

패키지 선언문은 첫번째 문장이어야함.

패키지명은 대소문자를 모두 허용하지만, 클래스명과 쉽게 구분하기 위해 소문자를 사용하는 것이 원칙

모든 클래스는 반드시 하나의 패키지에 속해야한다. 그러나 우리는 보통 패키지를 정해두지 않았지만 잘 작동되었다. 이것이 가능하게한 것은 ‘이름없는 패키지’ 때문이다.

### import 문

```java
import java.lang.*; //암묵적으로 항상 붙어있음
```

### import static 문

```java
import static java.lang.Integer.*;
import static java.lang.Math.random;
import static java.lang.System.out;

class StaticImportEx1{
	public static void main(String[] args){
		//System.out.println(Math.random());
		out.println(random()); //이게 가능
		//System.out.println("Math.PI :"+Math.PI);
		out.println("Math.PI :"+PI); //이게 가능
	}
}
```

static import를 사용하면 static 멤버를 호출할때 클래스 이름을 생략할 수 있다.

---

## 4장 제어자

### 종류

1. **접근 제어자**
    1. public, protected, default, private
2. **그 외**
    1. static, final, abstract, native, transient, synchronized, volatile, strictfp

---

### static

**클래스의, 공통적인**

| 제어자 | 대상 | 의미 |
| --- | --- | --- |
| static | 멤버변수 | 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.
클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
클래스가 메모리에 로드될 때 생성된다. |
|  | 메서드 | 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다. |

### final

**마지막 , 변경될 수 없는**

| 제어자 | 대상 | 의미 |
| --- | --- | --- |
| final | 클래스 | 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다. |
|  | 메서드 | 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다. |
|  | 멤버변수
지역변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다 |

**생성자**를 이용한 final 멤버 변수의 초기화

보통은 final이 붙은 변수는 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 **생성자에서 초기화** 되도록 할 수 있다.

### abstract

**추상의, 미완성의**

| 제어자 | 대상 | 의미 |
| --- | --- | --- |
| abstract | 클래스 | 클래스 내에 추상 메서드가 선언되어 있음을 의미한다 |
|  | 메서드 | 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다 |

추상 클래스는 아직 완성되지 않은 메서드가 존재하는 **미완성 설계도**이므로 **인스턴스를 생성할 수 없다.**

추상 클래스는 자체로는 쓸모가 없지만 다른 클래스가 이 클래스를 상속받아서 일부의 원하는 메서드만 오버라이딩해도 된다는 장점이 있다.

---

### 접근 제어자

```java
public > protected > (default)> private
```

| 대상 | 사용가능한 접근 제어자 |
| --- | --- |
| 클래스 | public, (default) |
| 메서드 | public , protected, (default) , private |
| 멤버 변수 | public , protected, (default) , private |
| 지역변수 | x |

**접근 제어자를 이용한 캡슐화**

1. 외부로부터 데이터를 보호하기 위해서
2. 외부에는 불필요한, 내부적으로만 사용되는 , 부분을 감추기 위해서

**생성자의 접근 제어자**

생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다. 
보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정할 수 있다. 

생성자한테 private을 주면 외부에서 생성자에 접근이 불가하여 인스턴스를 생성할 수 없다. 그래도 클래스내부에서는 인스턴스를 생성할 수 있다.

대신 인스턴스를 생성해서 반환해주는public 메서드를 제공해서 외부에서 클래스의 인스턴스를 사용하도록 할 수 있다. public 그리고 static이어야한다. 

그러나 이 경우에는 다른 클래스의 조상이 될 수 없다. 따라서 클래스 앞에 final을 붙여야한다.

### 제어자의 조합

1. 메서드에 static과 abstract를 함께 사용할 수 없다.
    1. 스태틱은 모두 구현된 메서드에만 사용할 수 있기 때문
2. 클래스에 abstract와 final 을 동시에 사용할 수 없다.
    1. final은 extends를 불가하게 하고
    abstract는 extends를 통해야만 하기에 모순되기 때문
3. abstract 메서드의 접근 제어자가 private일 수 없다.
    1. abstract 메서드는 상속을 통해 완성해야하는데,
    private의 경우에 상속을 해도 접근할 수 없기 때문이다.
4. 메서드에 private와 final을 같이 사용할 필요는 없다.
    1. 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다.
    이 둘 중 하나만 사용해도 의미가 충분

---

## 5장 다형성

### 다형성

**조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조**할 수 있도록 하였다는 것

반대는 불가.

### 참조변수의 형변환

> 자손 타입 → 조상 타입 (Up- casting): 형변환 생략가능
조상 타입 → 자손 타입 (Down- casting): 형변환 생략가능
> 

자식 타입의 참조변수를 조상 타입으로 형변환하는 것은 참조변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하므로 문제가 되지 않는다.

따라서 형변환을 생략할 수 있다.

형변환은 참조변수의 타입을 변환하는 것이지 인스턴스에는 아무런 영향을 주지 못한다.

단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위를 조절하는 것이다.

인스턴스 자체가 자식 클래스가 아닌 한, 다운캐스팅은 런타임에러를 낸다. 

> 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.
> 

### instanceof 연산자

```java
void doWork(Car c){
	if (c instanceof FireEngine){
		FireEngine fe =new FireEngine();
		fe.water();
	}else if(c instance of Ambulance){ // 객체는 Ambul 객체
		Ambulance a=(Ambulance)c; // 일단 Car 참조변수로 가리키고 있으니까 다운 캐스팅
		a.siren();
	}
}
```

> 어떤 타입에 대한 instanceof 연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
> 

### 참조변수와 인스턴스의 연결

**메서드의 경우**

부모 클래스의 메서드를 자식 클래스에서 오버라이딩한 경웨도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서가 호출된다.

**그러나 멤버변수의 경우 참조변수의 타입에 따라 달라진다**

+a) static 메서드는 static 변수처럼 참조변수의 타입에 영향을 받는다. 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다. 그래서 항상 static 메서드는 클래스를 통해 호출하자..

### 매개변수의 다형성

### 여러 종류의 객체를 배열로 다루기

**Vector() 클래스**

| 메서드/ 생성자 | 설명 |
| --- | --- |
| Vector() | 객체 생성. 디폴트는 10개, 그 후는 점차 증가 |
| boolean add(Object o) | 객체 추가 |
| boolean remove(Object o) | 객체 제거 |
| boolean isEmpty() | 벡터가 비어있는지 검사 |
| Object get(int index) | 객체 가져오기 |
| int size() | 객체 개수 반환 |

---

## 6장 추상 클래스

> 추상 클래스는 미완성 설계도이다. 추상 메서드를 포함하고 있다는 암시.
> 

꼭 추상메서드를 포함하고 있어야하는 것은 아니다. 추상메서드가 없는 완성된 클래스라 할지라도 추상클래스로 지정되면 클래스의 인스턴스를 생성할 수 없다. 

### 추상메서드

```java

/*
	주석을 통해 어떤 기능을 수행할지 써둠
*/
abstract 리턴타입 메서드이름();

abstract class Player{
	abstract void play(int pos);
	abstract void stop();
}

class AudioPlayer extends Player{
	void play (int pos){/* 구현부 */};
	void stop (){/* 구현부 */};
}
class AbstractPlayer extends Player{
	void play (int pos){/* 구현부 */};
}
```

> 만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자식 클래스 역시 추상클래스로 지정해주어야한다.
> 

### 추상클래스의 작성

상속이 자식 클래스를 만드는데 부모 클래스를 사용하는 것이라면, 

이와 반대로 추상화는 기존의 클래스의 공통부분을 뽑아내어 조상 클래스를 만드는 것이라고 할 수 있음.

> **추상화: 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업
구체화: 상속을 통해 클래스를 구현, 확장하는 작업**
> 

```java
abstract void stop(); //추상 메서드
void stop(){}; //일반 메서드
```

---

## 7장 인터페이스

인터페이스는 **일종의 추상클래스**이다. 

오직 추상메서드와 상수만을 멤버로 가질 수 있고, 다른 어떠한 요소는 허용하지 않는다.

### 인터페이스의 작성

```java
interface 인터페이스이름{
	public static final 타입 상수이름= 값;
	public abstract 메서드 이름(매개변수목록);
}
```

**제약사항**

1. 모든 멤버변수는 `public static final` 이어야하며, 이를 생략할 수 있다.
2. 모든 메서드는 `public abstract` 이어야하며, 이를 생략할 수 있다.
    1. 단 static 메서드와 디폴트 메서드는 예외 (jdk 1.8부터)

### 인터페이스의 상속

인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와 달리 다중상속, 즉 여러개의 인터페이스로부터 상속을 받는 것이 가능하다.

### 인터페이스의 구현

`implements` 를 통해 구현한다. 

만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야한다.

```java
interface Fightable extends Movable, Attackable{};

abstract class Fighter implements Fightable{};
```

그리고 다음과 같이 **상속**과 **구현**을 동시에 할 수도 있습니다.

```java
class Fighter implements Fightable extends Unit{
	public void move(int x, int y){/* 구현부 */};
	public void attack(Unit u){/* 구현부 */};
};
```

인터페이스의 이름에는 주로 Fightable과 같이 ~을 할 수 있는 의미인 able로 끝나는 것들이 많음. 

1. 어떠한 기능 또한 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조
2. 그 인터페이스를 구현한 클래스는 ‘~를 할 수 있는’ 능력을 갖추었다는 의미이기도 하다. 

### 인터페이스를 이용한 다중상속 p.385

만일 두개의 클래스로부터 상속을 받아야할 상황이라면,

1. 두 부모 클래스 중에서 비중이 높은 쪽을 상속으로 택하고 다른 쪽은 클래스 내부에 멤버로 포함
2. 어느 한 쪽의 필요한 부분을 뽑아 인터페이스로 만든 다음 구현하도록 함

### 인터페이스를 이용한 다형성

다형성에 대해 학습할 때 자식 클래스의 인스턴스를 조상 타입의 참조변수로 참조하는 것이 가능하다는 것을 학습했다.

인터페이스도 동일하게 이를 구현한 클래스의 조상이므로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환도 가능하다.

```java
Fightable f = (Fightable) new Fighter();

Fightable f = new Fighter();
```

따라서 인터페이스는 다음과 같이 메서드의 매개변수의 타입으로 사용될 수 있다

**리턴 타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다**

### 인터페이스의 장점

1. 개발시간을 단축시킬 수 있다
2. 표준화가 가능하다
3. 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다
4. 독립적인 프로그래밍이 가능하다

### 인터페이스의 이해

1. **클래스를 사용하는 쪽 (User)과 클래스를 제공하는 쪽이 있다.**
2. **메서드를 사용(호출)하는 쪽 (User)에서는 사용하려는 메서드(Provider)의 선언부만 알면된다.**